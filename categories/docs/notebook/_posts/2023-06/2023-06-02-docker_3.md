---
title: 도커 (3) &#58 도커란
tags: [Docker]
sidebar:
  nav: categories
permalink: /categories/docs/notebook/docker_3/
article_header:
  type: cover
  image:
    src: /assets/images/docs/notebook/docker-banner.png
---

<div class="article__content" markdown="1">

&ensp; 도커란 무엇인지 알아보겠습니다.

---

## ✅ 도커란

### 도커란

- 오픈 소스 컨테이너 런타임
- 리눅스 컨테이너를 생성하고 사용할 수 있도록 하는 컨테이너화 기술의 일종
- 컨테이너 생성을 위한 이미지 기반 배포 모델 제공
- 컨테이너 환경 내에서 애플리케이션의 배포를 자동화
- 도커를 사용하면 컨테이너를 모듈식 가상 머신처럼 다룰 수 있음

### 도커 워크플로우

![Image](/assets/images/docs/notebook/docker/workflow-with-docker.png){:.shadow}

1. Node.js와 몽고 DB로 앱을 빌드
2. 커밋하면 젠킨스가 CI를 수행하며, 앱으로부터 도커 이미지를 추출
3. 추출된 커스텀 도커 이미지는 도커 저장소에 푸시됨 (타인이 접근할 수 없게 하고 싶다면 도커 저장소를 **Private**으로 설정)
4. 서버는 도커 저장소로부터 커스텀 도커 이미지를 다운로드
5. 몽고 DB는 도커 허브에서 공식 이미지를 다운로드
6. 배포•운영

### 도커 네트워크

- 도커는 컨테이너들이 실행될 도커 네트워크를 구축
- 같은 도커 네트워크 내에서는 컨테이너들 간에 통신할 수 있으나, 포트 번호로 통신하지는 않음
- 클라이언트(브라우저)는 애플리케이션에 접속할 때, 도커 네트워크 바깥에서 포트 번호로 접속

<br/>

## ✅ 도커 이해를 위한 기본 개념

### 가상화(Virtualization)

- 한 컴퓨터로부터 복수의 가상 하드웨어를 추출하고, 이를 기반으로 여러 대의 가상 컴퓨터처럼 사용하는 기술

### 가상 머신 vs 컨테이너

- 공통점

  - 배포 기술의 일종
  - 리소스로부터 독립된 실행 환경을 생성할 수 있음
  - 소프트웨어 패키지라 할 수 있는 '이미지' 개념을 차용

- 차이점

  - 가상 머신

    - 가상화 기술을 사용하여 가상 컴퓨팅 환경을 구축
    - 물리적 하드웨어를 가상화하며, 기반이 되는 컴퓨터(또는 서버)를 호스트라고 함
    - 가상 머신을 생성하는 것은 컴퓨터를 생성하는 것과 유사
    - 인프라 구축에 적합
    - _Long-running_

  - 컨테이너

    - 소프트웨어 배포 단위이며, 프로세스 그 자체

    - 인프라 구축보다는 애플리케이션 제어에 효율적
    - 애플리케이션 실행에 필요한 모든 것을 포함하고 있기 때문에 거의 모든 환경에서 실행시킬 수 있음
    - _Ephemeral_
    - 특징
      - 스테이트리스(Stateless) - 클라이언트 데이터를 저장하지 않음
      - 경량화(Portable) - 가상 머신보다 소모하는 리소스가 훨씬 적음
      - 비영구적 데이터 - 컨테이너가 삭제되면 내부 데이터도 삭제됨; 볼륨을 사용하여 극복

### 도커 이미지 vs 도커 컨테이너

- 이미지

  - 앱 패키지의 청사진

- 컨테이너

  - 이미지를 위한 런타임
  - 포트 번호가 있음
  - 가상 파일 시스템을 사용

### 컨테이너 포트 vs 호스트 포트 (🚀 연습 1)

&ensp; 터미널에 다음의 코드를 그대로 따라 입력합니다.

```zsh
docker run -d redis # 또는 redis의 이미지 ID
docker run -d redis:4.0
docker ps
```

&ensp; 실행된 두 컨테이너의 포트를 확인하면, 포트 번호가 같음을 확인할 수 있습니다. 한 포트 번호에는 하나의 프로세스만 실행될 수 있는데, 왜 충돌이 발생하지 않을까요?

&ensp; 그 이유는 컨테이너 포트와 호스트 포트는 별개이기 때문입니다. 컨테이너 포트는 호스트 포트에 종속되어 있는데, 이때 호스트 포트는 중복돼서는 안 되지만, 컨테이너 포트는 중복돼도 상관없습니다.

```txt
HOST_POPT:CONTAINER_PORT
3000:3000 # redis container
4000:3000 # redis:4.0 container
```

&ensp; 위와 같이 컨테이너 포트가 일치하는 상황이더라도, 컨테이너 포트로 포워딩해주는 것은 결국 호스트 포트입니다. 게다가, 도커에서 이를 알아서 관리해주므로, 컨테이너 포트가 중복되는 것에 신경 쓰지 않아도 됩니다.

### 도커 컨테이너 포트 포워딩

```zsh
docker run -p HOST_PORT_NO:CONTAINER_PORT_NO IMAGE_NAME
```

&ensp; 컨테이너를 실행할 때 호스트 포트와 컨테이너 포트를 지정하여 실행시킬 수도 있는데, 이 방법으로 컨테이너 포트 번호 중복을 피할 수 있습니다.

&ensp; `docker run -p 6000:6379 redis`를 실행하면 호스트 포트 6000번에 포트 번호 6379의 컨테이너를 바인딩할 수 있습니다.

---

**출처**

[도커란](<https://www.redhat.com/ko/topics/containers/what-is-docker#:~:text=%22Docker(%EB%8F%84%EC%BB%A4)%22%EB%8A%94,%EC%97%AC%EB%9F%AC%20%EC%9D%98%EB%AF%B8%EB%A5%BC%20%EB%9C%BB%ED%95%A9%EB%8B%88%EB%8B%A4.>)

</div>
