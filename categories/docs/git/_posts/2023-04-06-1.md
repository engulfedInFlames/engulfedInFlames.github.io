---
title: Git (1) &#58; reset, revert, stash
tags: [git]
sidebar:
  nav: categories
permalink: "/categories/docs/git/1"
article_header:
  type: cover
  image:
    src: https://git-scm.com/images/logos/2color-lightbg@2x.png
---

<!--more-->

<br/>

&nbsp;&nbsp; 스파르타 특강으로 git 명령어 (reset, revert, stash) 사용법을 배웠습니다. 기억을 되살려서 하나 하나 복습하도록 하겠습니다.

---

<br/>

### (1) git reset

&nbsp;&nbsp; reset 명령어는 커밋 이력을 취소하고나 삭제하고 싶을 때 (깔끔하게 로그 이력을 관리하고 싶을 때) 사용하는 명령어입니다. 종류에는 다음과 같이 3가지가 있습니다.

1. soft reset
2. mixed reset
3. hard reset

&nbsp;&nbsp; 세 가지 reset을 모두 사용해보도록 하겠습니다.

<br/>

<div align="center">
<img src="/imgs/docs/git/01.png" width="480">
</div>

<br/>

&nbsp;&nbsp; 위와 같이 3개의 커밋이 만들었고, 각 커밋에는 한 줄씩의 텍스트 입력이 변경사항으로 저장되어 있습니다. 먼저 soft reset을 해보겠습니다.

<br/>

##### 1. soft reset

&nbsp;&nbsp; soft reset은 현재 commit area의 changes를 staged area로 되돌립니다. 커밋을 취소하면서도 changes를 unstage area의 changes와는 섞이지 않게 하기 위함입니다. 이제 터미널에 "git reset --soft HEAD^"를 입력하겠습니다. "--soft"라는 옵션을 지정함으로써 soft reset할 것임을 알립니다.

<br/>

<div align="center" style="display:flex; justify-content: space-around;">
<img src="/imgs/docs/git/02.png" width="420" height= "240">
<img src="/imgs/docs/git/03.png" width="420" height= "240">
</div>

<br/>

&nbsp;&nbsp; 터미널에 "git reset --soft HEAD^"을 입력했습니다. 세 번째 줄에 텍스가 입력된 것이 가장 최근의 커밋이고, 두 번째 줄까지 입력된 것이 바로 직전의 커밋입니다. soft reset을 실행했기 때문에 commit area에서 세 번째 줄을 입력한 changes가 삭제됐음을 확인할 수 있습니다. 그리고 왼쪽에 소스 콘트롤창의 staged area에 changes가 생겨났음을 알 수 있습니다.
("HEAD^"은 HEAD가 위치한 커밋 로그로부터 하나 떨어진 커밋 로그로 돌아가겠다는 것을 의미합니다. 만약 둘, 셋 이상 떨어진 커밋 로그로 돌아가고 싶을 때는 "^"의 개수를 하나씩 늘려주면 됩니다. )

<br/>

##### 2. mixed reset

&nbsp;&nbsp; mixed reset은 현재 commit area의 changes를 unstaged area, 즉, working area로 되돌립니다. 커밋을 취소하고, 해당 changes의 staging마저 취소합니다. soft reset이나 hard reset처럼 명령어를 입력할 때 옵션을 따로 입력하지 않아도 됩니다.

&nbsp;&nbsp; 아까와 똑같이 3개의 커밋을 만들고, 터미널에 "git reset HEAD^^"를 입하겠습니다. "^"가 두 개임으로, 두 개의 커밋을 되돌려야 합니다. 총 세 개의 커밋 로그가 있는 상태에서 두 개의 커밋을 되돌리면 하나의 커밋, 즉, 최초의 커밋만 남아야 합니다.

<br/>

<div align="center" >
<img src="/imgs/docs/git/04.png" width="600">
</div>

<br/>

&nbsp;&nbsp; 두 번째 줄과 세 번째 줄이 삭제되고, 첫 번째 줄만 남았습니다. 그리고 changes가 staged area가 아닌 working area에 있습니다. 잘 동작했음을 알 수 있습니다.

<br/>

##### 3. hard reset

&nbsp;&nbsp; hard reset은 커밋 로그는 물론 changes까지 전부 되돌립니다. 롤백이라고 생각하면 될 것 같습니다. 바로 사용해보겠습니다.

&nbsp;&nbsp; 이번에는 두 번째 줄과 세 번째 줄의 입력을 "Wrote extra lines"라는 커밋 메세지를 가진 하나의 커밋에 저장하고, 터미널에 "git reset --hard HEAD^"를 입력하겠습니다.

<br/>

<div align="center" style="display:flex; justify-content: space-around;">
<img src="/imgs/docs/git/05.png" width="420" height= "240">
<img src="/imgs/docs/git/06.png" width="420" height= "240">
</div>

<br/>

&nbsp;&nbsp; 오른쪽 이미지를 통해 hard reset이 잘 됐음을 알 수 있습니다. 첫 번째 줄의 텍스트만 남아 있고, 소스 콘트롤 창에 changes도 보이지 않습니다. 또, 터미널에 "HEAD is now at d1cf44d Wrote the first line"이라고 출력됐습니다 HEAD가 첫 번째 커밋 로그로 잘 이동했음을 확인할 수 있습니다.

<br/>

### (2) git revert

&nbsp;&nbsp; revert는 이전 로그와 완전히 동일한 새로운 로그를 생성합니다. reset은 커밋 로그를 삭제하기 때문에 원격저장소에서 push를 하게 되면, 원격저장소의 커밋 로그를 덮어 써야 하기 때문에 강제(--force)로 push를 해야만 합니다. revert는 이와 같은 불편함을 해소하기 위해 커밋을 삭제하는 것이 아닌, 이전 커밋과 같은 새로운 커밋을 추가합니다. 단점이라면, revert를 자주 사용하게 되면 커밋 이력이 지저분해질 수 있습니다. 바로 사용해보겠습니다.

> revert는 취소할 commit hash를, reset은 되돌아갈 commit hash를 입력해야 한다.

<br/>

<div align="center" style="display:flex; justify-content: space-around;">
<img src="/imgs/docs/git/07.png" width="420" height= "320">
<img src="/imgs/docs/git/08.png" width="420" height= "320">
</div>

<br/>
&nbsp;&nbsp; 처음과 마찬가지로 3개의 커밋 로그(왼쪽 이미지)를 만듭니다. 그리고 터미널에 "git revert"를 입력했습니다. 그 결과 두 번째 커밋 로그의 변경사항을 가지고 새로운 커밋이 생성됐음을 확인할 수 있습니다. 소스 콘트롤 창에도, 터미널에도 revert가 동작했음을 알리는 내용(오른쪽 이미지)이 출력되어 있습니다.

<br/>

<div align="center" >
<img src="/imgs/docs/git/09.png" width="600">
</div>

<br/>

&nbsp;&nbsp; 위 이미지와 같이 커밋 로그도 새로 추가되어 4개가 됐음을 확인할 수 있습니다. 추가로, reset도 마찬가지지만, 뒤에 commit hash를 입력하여 특정 커밋 로그에 대해 명령을 실행할 수도 있습니다.

<br/>

### (3) git stash

&nbsp;&nbsp; stash는 작업 내용을 임시 저장합니다. 작업 중 요청을 받아 다른 프로젝트를 작업하러 가게 되거나, 혹은 같은 프로젝트에서 다른 브랜치로 가야 할 때에 주로 사용합니다. 커밋 이력으로 남기기는 껄끄러우나, 이전 커밋에 비해 어디가 변경되었는지는 알아야 할 때 사용할 수 있습니다. 바로 사용해보겠습니다.

&nbsp;&nbsp; 처음과 마찬가지로 3줄의 텍스트를 입력하겠습니다. 다만, 두 번째 입력까지에 대해서만 커밋을 실행할 것입니다. 따라서, 두 개의 커밋 로그만 생성되고, 세 번째 줄에 대해서는 커밋 로그가 생성되어 있지 않은 상황이 됩니다. 이 상황에서 터미널에 "git stash -m '메세지'"를 입력하겠습니다.

<br/>

<div align="center" >
<img src="/imgs/docs/git/10.png" width="600">
</div>

<br/>

&nbsp;&nbsp; 터미널을 통해 무엇인가 잘 저장됐음을 확인할 수 있습니다. 그리고 script.txt에도 세 번째 줄이 삭제됐음을 통해 작업 내용이 저장됐음을 알 수 있습니다. 그렇다면 실제 저장됐는지 확인해보겠습니다. 터미널에 "git stash list"를 입력하겠습니다. "git stash list"는 stash 명령어로 임시 저장 이력을 출력합니다.

<br/>

<div align="center" >
<img src="/imgs/docs/git/11.png" width="600">
</div>

&nbsp;&nbsp;stash list에 제가 stash할 때 남긴 메세지가 보입니다. stash가 잘 동작했음을 확인할 수 있습니다. 출력 내용에서 처음에 보이는 stash@{0}은 순서를 나타냅니다. stash가 쌓일 수록 "{}"안의 0, 1, 2, 3... 순으로 인덱스가 증가합니다.

&nbsp;&nbsp; 이번에는 stash한 것을 다시 불러오도록 하겠습니다. 이때는 "git stash apply" 명령어를 사용합니다. 이 명령어를 통해 stash list에 기록된 임시 저장된 변경 사항들을 불러올 수 있습니다. 이 명령어 뒤에는 인덱스 번호를 붙임으로써, 해당 인덱스의 임시 저장된 변경 사항을 불러올 수 있습니다. 제 stash list에는 0번째 인덱스밖에 없었으므로, 0을 붙이도록 하겠습니다. 터미널에 "git stash apply 0"를 입력합니다.

<div align="center" >
<img src="/imgs/docs/git/12.png" width="600">
</div>
