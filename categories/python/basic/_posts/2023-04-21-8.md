---
title: Basic Python (8) &#58; Async I/O Part 1 - 병렬 처리의 의미 및 멀티 스레딩과 Async의 차이
tags: [Python, Async]
sidebar:
  nav: categories
permalink: "/categories/python/basic/8"
article_header:
  type: cover
  image:
    src: /assets/images/python/basic/async_with_python-banner.png
---

<!--more -->

<br/>

&nbsp;&nbsp; 이번 포스트를 시작으로 파이썬의 Asnyc에 관한 총 6개의 포스트를 연재할 것입니다. 각 포스트의 주제는 다음과 같습니다.

1. 병렬 처리의 의미 및 멀티 스레딩과 Async의 차이
2. 이벤트 루프
3. 코루틴(Coroutines)
4. Coroutines Under The Hood
5. Batteries Included
6. An Example Web Application With Starlette and EdgeDB

&nbsp;&nbsp; 위 6개 주제는 다음의 유튜브 영상을 **참조 요약**한 것으로, 파이썬 Asnyc가 처음이거나, 이해가 잘 안 될 때는 해당 영상을 참조하시기를 바랍니다.

[Import asyncio by EdgeDB](https://www.youtube.com/watch?v=Xbl7XjFYsN4&list=PLhNSoGM2ik6SIkVGXWBwerucXjgP1rHmB)

&nbsp;&nbsp; 이번 포스트에서는 첫 번째 주제 멀티 스레딩과 Async의 차이를 다룰 것입니다.

---

### (1) 병렬 처리가 필요한 이유

&nbsp;&nbsp; 유튜브 쇼츠 영상(혹은 페이스북이나 인스타그램 게시글)을 본다고 가정합시다. 사용자는 1시간이고, 2시간이고 침대에 누워서 손가락으로 영상을 위로 올기만 하면 수십, 또는 수백 개의 영상을 볼 수 있습니다. 10시간이 돼도 다르지 않습니다. 사용자는 10시간 동안 무한대로 스크롤(인피니티 스크롤)할 수 있습니다.

&nbsp;&nbsp; 그렇다면 이 쇼츠 영상들의 데이터는 어떻게 우리의 스마트폰 안에 들어오고 있는 것일까요? 유튜브가 사용자의 평균 쇼츠 영상 시청 시간을 분석하여, 쇼츠 버튼을 클릭했을 때 그만큼의 데이터를 쿼리하는 걸까요?

&nbsp;&nbsp; 여기서 유튜브에 접속했을 때 데이터가 쿼리되는 원리를 다루지는 않을 것입니다만, 한 가지 확실한 것은 우리가 쇼츠 버튼을 클릭했다고 해서, 유튜브가 그 대량의 데이터를 쿼리하지는 않는다는 것입니다. 만약 그렇다면 쇼츠 영상ㄲ을 볼 때 큰 지연 시간(Latency)가 생길 것이고, 영상을 오래 보는 사람일 수록 지연 시간이 더 길어질 것입니다.

&nbsp;&nbsp; UI는 기본적으로 사용자 경험을 방해하지 않는 방향으로 설계되어야 합니다. 만약 위의 예시처럼 쇼츠 영상의 인피니티 스크롤이 대량의 데이터 쿼리에 의해 가능한 것이라면, 사용자는 쇼츠 버튼을 누르고 첫 영상을 볼 때까지 긴 시간을 기다려야만 할 것입니다.

&nbsp;&nbsp; 반대로, 스크롤할 때마다 다음 영상을 준비하기 위해 데이터가 쿼리되는 것이라면, 사용자가 스크롤했음에도 영상이 아닌 로딩 화면을 먼저 보게 되거나, 빠른 스크롤을 감당하지 못해 기기가 버벅이는 사태도 발생할 것입니다. 그렇게 되면 인피니티 스크롤은 유명무실이 됩니다.

&nbsp;&nbsp; 그래서 위 두 가지 극단 사이의 중간 지점을 택해야 합니다. 이때 동기 처리(Syncronous Execution)와 비동기 처리(Asyncronous Execution)가 등장합니다.

&nbsp;&nbsp; 이전 포스트에서도 다뤘지만, 컴파일러가 동기 처리를 하면 코드는 실행 순서에 맞춰서 곧바로 실행됩니다. 가령, 단순히 쇼츠 영상을 대량으로 쿼리하는 코드를 작성하고, 그밑에 바로 해당 데이터를 출력하는 코드를 작성했다고 가정해봅시다. 데이터 쿼리에는 지연 시간(Latency)이 있을 것이고, 바로 밑의 출력 코드가 실행되기까지의 그 짧은 순간에 데이터는 존재하지 않게 됩니다. 따라서 null 값이 출력되거나, 오류가 발생할 것입니다. 일차선에서 앞에 가던 차가 급정차하면 뒤에 있는 차들 역시 정차하게 되는 것과 같습니다. 뒤차가 앞차를 뛰어넘을 수는 없습니다. 이때 차선이 몇 개 더 있어서 뒤에 있는 차들이 다른 차선으로 이동할 수 있다면(병렬 처리), 상황은 더 나아질 것입니다.

<br/>

### (2) 멀티 스레딩(Multi Threading)

&nbsp;&nbsp; 프로그래밍에서 병렬 처리를 하려면 어떻게 해야 할까요? 간단하게 하나의 프로세스에 대해, 싱글 스레드가 아니라 멀티 스레드로 작업시키는 방법은 어떨까요?

&nbsp;&nbsp; 멀티 스레드로 작업한다는 것은 프로세스 입장에서 일꾼이 여럿이 된 것이니, 작업 능률은 오를 것입니다. 하지만 멀티 스레드는 스레드 간에 리소스를 공유한다는 사실에 주의해야 합니다.

&nbsp;&nbsp; A, B, C, 3개의 스레드가 어떤 리소스 R을 공유하여 작업하고 있다고 가정합시다. 순조롭게 작업하고 있는 중에, A가 갑자기 R의 상태를 변경시키려 하고, B와 C는 이를 인지하지 못한 상황이라면 오류가 발생하게 될 것입니다. (오류가 발생하지 않으면 디버깅 해야 한다는 사실 조차 놓치게 되므로, 차후에 더 심각한 상황을 초래할 수 있습니다.) 오류가 발생하지 않게 하라면 B와 C에게 R의 상태 변경을 인식시키는 동기화(Syncronization)를 해야만 합니다.

<br/>

### (3) 스레드의 자원 접근 메커니즘 : 락(Lock)

&nbsp;&nbsp; 이처럼 여러 스레드가 자원에 접근해야 하는 상황에서, 이를 통제하는 메커니즘 중 하나가 바로 락입니다. 락은 말그대로 특정 작업을 위해 하나의 스레드가 해당 리소스를 락, 즉, 잠금하는 것입니다. 리소스가 락되면 다른 스레드는 해당 리소스에 대한 접근이 차단됩니다. 접근이 차단되고, 리소스를 점유하고 있는 스레드가 작업을 완료하면 락이 풀리고, 다른 스레드들도 해당 리소스에 접근할 수 있게 됩니다.

&nbsp;&nbsp; 분명히 락을 사용해야만 하는 상황들이 있겠지만, 단순히 리소스 사용이나 작업 능률 측면에서 락은 그다지 효율적으로 보이지 않습니다. 한 두개면 모를까, 수십 개의 스레드가 돌아가는 상황에서 점유된 리소스 몇 개 때문에 해당 리소스를 공유하는 모든 스레드가 작업을 중단해야 하는 상황을 상상하면 말입니다. 한편으로, 락이 많아지면 그만큼 프로세스의 속도 역시 저하됩니다.

> 락 경합(contetion): 락에서 리소스를 점유하기 위해 스레드 간에 경쟁하는 것

&nbsp;&nbsp; 이처럼 병행 처리를 위한 멀티 스레딩 최적화(Optimization)는 까다롭습니다. 할당된 일을 병행 처리하기 위해 위와 같이 복잡한 최적화를 수행하는 것은 번거로운 일이 될 것입니다. 이때 Asnyc가 빛을 발합니다.

<br/>

### (4) Async와 멀티 스레딩의 차이

&nbsp;&nbsp; 앞서 스레드를 일꾼으로 비유한 적이 있습니다. Asnyc는 일꾼이 아니라 "일"입니다.

&nbsp;&nbsp; 멀티 스레딩을 바텐더에 비유하자면, 바텐더와 손님이 위치한 바는 프로세스에, 스레드는 바텐더에, 손님은 일(작업)이라고 할 수 있습니다. 멀티 스레딩은 각각의 손님에게 담당 바텐더를 지정하는 것과 같습니다. 때때로 손님들 간에 메뉴가 중복되거나, 메뉴를 준비하기 위해 필요한 재료라든지 도구들이 중복될 수 있습니다. 그렇게 되면 어떻게 효율적으로 늦지 않게 손님들의 메뉴를 준비할 수 있을지 고민해야 합니다. 그 방법 중 하나가 위의 락(Lock)입니다.

&nbsp;&nbsp; 같은 비유로 asnyc를 설명하면, async는 한 명의 바텐더가 여러 손님들을 맞이하는 것과 같습니다. 그리고 바텐더는 다수의 손님들과 동시에 대화도 하고, 주문도 받고, 순서도 기억합니다. 게다가, 한 메뉴를 준비하면서 여유가 있으면 다른 메뉴를 동시에 준비할 수도 있습니다. 하지만 내놓은 메뉴는 한 가지씩입니다.

&nbsp;&nbsp; 이때 중요한 것은 바텐더가 한 사람에게서만 주문을 받고, 그 사람에게 음료를 내놓을 때까지 다른 사람들과 대화하지 않는 것이 아니라, 음료는 내놓지 않을지언정 다른 손님들과도 대화를 하고 있다는 것입니다. 전자를 Blocking, 후자를 Non-blocking이라고 합니다.

<br/>

### (5) AsycnIO의 목표

&nbsp;&nbsp; Async I/O의 목표는 I/O를 비동기 처리로 작업들을 병렬 처리함으로써, **싱글 스레드의 활용도를 극대화**하는 것입니다. 바텐더의 예시처럼 한 가지 메뉴를 준비하고 있더라도, 여유가 있으면 다른 메뉴를 준비하는 것과 같습니다. 오븐에 음식을 넣고 데우는 동안, 손이 비어 있으니 다른 음식을 준비하는 것입니다!

&nbsp;&nbsp; 가능하다면 병행 처리를 위해 멀티 스레딩, 멀티 프로세싱, 멀티 OS, 멀티, 멀티..., 를 할 수도 있겠습니다...만! 최소 투입으로 최대 산출을 끌어내는 것이 프로그래밍의 지향점 중 하나라는 사실을 명심한다면 Asnyc의 가치를 확인할 수 있습니다. Async의 가치는 앞에 명시한 대로 싱글 스레드로 작업들을 병렬 처리할 수 있다는 것입니다. 이는 JS와 같은 싱글 스레드 언어나 싱글 스레드 프로세스 등에 특히 진가를 발휘합니다.

---

**출처**

[Import asyncio by EdgeDB](https://www.youtube.com/watch?v=Xbl7XjFYsN4&list=PLhNSoGM2ik6SIkVGXWBwerucXjgP1rHmB)
