---
title: "youRfan (6) : 리액트에 장고 채널스 연결하기"
tags: [Sparta, React, Django]
sidebar:
  nav: categories
permalink: "/categories/sparta/projects/yourfan_6"
---

<div class="article__content" markdown="1">

&ensp; 팀원이 백엔드에 장고 채널스를 사용하여 소켓 연결을 할 수 있는 환경을 마련해놨습니다. 이제 프론트와 연결하기만 하면, 채팅 기능을 구현할 수 있습니다. 이번 포스트에서는 장고 채널스 셋업 과정을 간략하게 소개하고, 리액트 프론트와 연결하기까지의 과정을 중점적으로 다루겠습니다.

---

## ✅ 웹소켓에 대한 기본 이해

- 화상 회의나 채팅 프로그램과 같이 양방향 통신을 위해 항상 연결되어 있어야 하는 앱에서는 HTTP 연결이 비효율적 => 웹소켓 사용
- 웹소켓을 사용하면 요청-응답 없이 개방형 네트워크에 연결된 모든 사용자들이 실시간 및 양방향으로 데이터를 통신할 수 있음
- 웹소켓은 초기 연결시의 인증 과정을 거친 후에는 연결이 끊길 때까지 추가 인증이 필요하지 않음
- 장고 채널스(Django Channels)는 웹소켓과 레디스 기반의 통신 환경을 제공

<br/>

## ✅ 리액트와 장고 채널스를 연결하기 (개괄)

### 장고 채널스 셋업

- 장고 프로젝트에 장고 채널스 설치 (`pip install channels channels-redis`)
- 프로젝트에 장고 채널스 실행을 위한 환경을 설정
- 웹소켓 연결을 위한 라우팅을 설정 - 소켓을 통해 오가는 메세지를 핸들링할 핸들러를 정의

### 장고 채널스 컨슈머

- 장고 채널스에서 제공하는 클래스를 상속하는 컨슈머를 생성

  - 클래스: `channels.generic.websocket.WebsocketConsumer`

- `connect`, `disconnect`, `receive` 등 메세지 핸들러 구현

&ensp; (현재 여기까지 셋업이 완료된 상태입니다.)

### 리액트와 연결하기

- 리액트에서도 장고 채널스 서버와의 연결을 위한 관련 모듈을 설치
- 통상 `useEffect` 훅을 사용하여 연결을 설정
- `open`, `message`, `close`, `error` 등 메세지 핸들러 구현

### 리액트에서 메세지 송수신하기

- `send` 메소드를 사용하여 메세지를 보내고, `message` 이벤트를 리스닝하여 수신한 메세지를 핸들링

<br/>

## ✅ 실제 연결하기

### Websocket 설치하기

&ensp; 먼저 리액트 앱에 필요한 웹소켓을 설치합니다. 타입스크립트를 사용하고 있으므로, 웹소켓의 타입 정의를 포함하고 있는 `@types/websocket`도 설치합니다.

```zsh
npm install websocket @types/websocket
```

### 컴포넌트 로직 구현

&ensp; 다음으로 채팅방으로 사용할 컴포넌트를 정의합니다. 컴포넌트명은 *Colloqium*입니다. (컴포넌트 정의는 [여기](https://blog.logrocket.com/build-chat-application-react-django-channels/)를 참조했으며, GPT에게 요청하여 클래스형 컴포넌트를 함수형 컴포넌트로 변환했습니다.)

```jsx
export default function Colloquium() {
  const { channel } = useParams();
  const channelTitle = channel?.split("@").pop();
  const [messages, setMessages] = React.useState<IMessage[]>([]);
  const { user } = useMe();
  const accessToken = Cookies.get("access");
  ...
}
```

&ensp; `useParams`로 URL에 있는 `channel` 파라미터를 가지고 옵니다. 이 파라미터는 유튜브에서 라우팅하는 것과 같이 '@'와 채널 핸들명으로 구성되어 있습니다. 백엔드의 웹소캣 채널명은 이 '@'를 제외한, 채널 핸들명만으로 되어 있기 때문에 `split`과 `pop` 메소드를 조합하여, 채널 핸들만을 취하여 `channelTitle`이라는 변수에 할당합니다.

&ensp; `messages`에는 웹소켓으로 오가는 메세지 데이터들을 저장합니다.

&ensp; `useMe`는 로그인한 유저의 데이터를 반환하는 커스텀 훅입니다.

&ensp; `accessToken`은 로그인했을 때에 백엔드에서 발급한 JWT입니다.

```jsx
export default function Colloquium() {
  ...
  const client = new W3CWeboSocket(
    `ws://127.0.0.1:8000/ws/chat/${channelTitle}/?token=${accessToken}`
  );

  React.useEffect(() => {
    client.onopen = () => {
      console.log("WebSocket Client Connected");
    };
    client.onmessage = (message) => {
      const dataFromServer = JSON.parse(message.data.toString());
      if (dataFromServer) {
        setMessages((prevMessages) => [
          ...prevMessages,
          {
            message: dataFromServer.message,
            user_nickname: dataFromServer.user,
          },
        ]);
      }
    };
    return () => {
      client.close();
    };
  }, []);
  ...
}
```

&ensp; 다음으로 `W3CWebSocket`(`w3cwebsocket`의 별칭)으로 클라이언트를 생성합니다. (클라이언트는 개발자 입장에서는 컨트롤러를 의미합니다.)

```jsx
const client = new W3CWebSocket(
  `ws://127.0.0.1:8000/ws/chat/${channelTitle}/?token=${accessToken}`
);
```

&ensp; `channelTitle`은 장고 채널스로 생성된 채널의 이름이며, 백엔드는 `accessToken`을 통해 사용자를 인증합니다. 채널은 이미 생성되어 있는 상태로, 프론트에서는 클라이언트만을 생성하여 해당 채널에 웹소켓 연결만을 시도합니다.

```jsx
React.useEffect(() => {
  client.onopen = () => {
    console.log("WebSocket Client Connected");
  };
  client.onmessage = (message) => {
    const dataFromServer = JSON.parse(message.data.toString());
    if (dataFromServer) {
      setMessages((prevMessages) => [
        ...prevMessages,
        {
          message: dataFromServer.message,
          user_nickname: dataFromServer.user,
        },
      ]);
    }
  };
  return () => {
    client.close();
  };
}, []);
```

&ensp; 클라이언트를 생성했다면, `useEffect`로 웹소켓에 의한 사이드 이펙트를 컨트롤합니다. 디펜던시를 빈 배열로 할당하여, 마운트됐을 시에만 동작하게끔 합니다. 이렇게 함으로써, 마운트됐을 때(`componentDidMount`)에 클라이언트에 이벤트 핸들러(`onopen`, `onmessage`)가 추가되게 할 수 있습니다. `onmessage`는 메세지가 송수신됐을 시의 이벤트 핸들러로, `messages` 변수에 해당 메세지들을 추가합니다. 이 `messages` 변수가 갱신될 때마다 컴포넌트가 리렌더링될 것입니다.

&ensp; 마지막으로 `useEffect`의 클린업 메소드를 통해 메모리 누수를 방지합니다. 클린업은 채널과 `client`의 연결이 끊겼을 때에 실행됩니다.

```jsx
const onSubmitMessage = (event: React.FormEvent<HTMLDivElement>) => {
  event.preventDefault();
  const input = event.currentTarget.querySelector("input[name='message']");
  if (input instanceof HTMLInputElement) {
    client.send(
      JSON.stringify({
        type: "chat_message",
        message: input.value,
        user_nickname: user?.nickname,
      })
    );
  }
};
```

&ensp; 메세지 전송 버튼을 눌렀을 때의 이벤트도 핸들링해야 합니다. 해당하는 JSX는 다음과 같습니다. 저는 컴포넌트 라이브러리로는 Chakra UI를 사용했으며, 레퍼런스에서는 Material UI를 사용했습니다.

```jsx
<FormControl as="form" onSubmit={onSubmitMessage} isRequired>
  <Input name={"message"} placeholder={"메세지를 입력하세요"} />
  <IconButton type={"submit"} aria-label={"Send Message Button"} />
</FormControl>
```

&ensp; 메세지 입력란은 `form` 태그로 구성되어 있기 때문에 `FormEvent`로 처리해야 합니다. 전송 버튼을 누르면 `Input` 태그의 `value`를 JSON 형식으로 변환하여 `client`의 `send` 메소드의 인자로 담아 서버로 전송합니다. 위에서 JSON으로 변환되는 데이터들의 양식은 임의 지정하는 것이 아니며, 장고 채널스에서 지정한 양식에 맞춰서 보내야만 합니다. 참고로 저희 백엔드 프로젝트에서는 메세지 양식을 다음과 같이 지정하고 있습니다.

```python
async def receive(self, text_data):
    text_data_json = json.loads(text_data)
    message_content = text_data_json["message"]
    user_nickname = self.scope["user"].nickname

    # Send message to room group
    await self.channel_layer.group_send(
        self.room_group_name,
        {
            "type": "chat_message",
            "message": message_content,
            "user_nickname": user_nickname,
        },
    )
```

&ensp; 이것으로 웹소켓 연결을 위한 컴포넌트 로직 구현이 끝났습니다. 이제 JSX만 정의하면 됩니다.

### JSX 구현

```jsx
import React from "react";
import { useParams } from "react-router-dom";
import {
  Flex,
  FormControl,
  IconButton,
  Input,
  Text,
  VStack,
} from "@chakra-ui/react";
import { MdSend } from "react-icons/md";
import { w3cwebsocket as W3CWebSocket } from "websocket";
import Cookies from "js-cookie";
import ForumTabs from "../components/Forum/ForumTabs";
import Message from "../components/Forum/Message";
import { IMessage } from "../type";
import { useMe } from "../hooks/userHooks";

export default function Colloquium() {
  ...컴포넌트 로직

  return (
    <VStack w={"80%"} minH={"768px"} my={24} mx={"auto"} p={8}>
      {channel ? <ForumTabs channel={channel} /> : null}
      <VStack userSelect={"none"} w={"full"} flex={1} p={8}>
        <Flex
          position={"relative"}
          w={"full"}
          flex={1}
          shadow={"inner"}
          borderRadius={"lg"}
        >
          <Text
            position={"absolute"}
            top={4}
            left={4}
            fontSize={"xl"}
            fontWeight={"semibold"}
          >
            현재 참여 인원 ()
          </Text>
          <VStack
            flex={1}
            justifyContent={"flex-start"}
            alignItems={"flex-start"}
            px={4}
            pt={16}
            pb={4}
          >
            {messages.map((message, index) => (
              <Message key={index} message={message} />
            ))}
          </VStack>
        </Flex>
        <FormControl
          as="form"
          onSubmit={onSubmitMessage}
          isRequired
          w={"full"}
          display={"flex"}
          alignItems={"center"}
        >
          <Input
            name={"message"}
            focusBorderColor={"primary"}
            errorBorderColor={"youtubeRed"}
            placeholder={"메세지를 입력하세요"}
            variant={"flushed"}
          />
          <IconButton
            type={"submit"}
            icon={<MdSend />}
            aria-label={"Send Message Button"}
            w={28}
            _hover={{ bgColor: "tertiary", color: "white" }}
            _focus={{ bgColor: "secondary", color: "white" }}
            variant={"outline"}
          />
        </FormControl>
      </VStack>
    </VStack>
  );
}
```

<br/>

## ✅ 결론

![Result Images](){:.shadow}

&ensp; 웹소켓이 정상적으로 연결됐습니다. 하지만 개선해야 할 부분도 몇 가지 있습니다. 첫 번째는, 메세지를 빠르게 입력하면 오류가 발생합니다. 리액트 오류창을 닫으면 다시 정상적으로 동작하기 때문에 개발 모드에서만 발생하는 오류일 가능성도 있습니다만, 염두에 두고는 있어야겠습니다. 두 번째는 채널명이 한글로는 안 된다는 것입니다. 이를 해결하기 위해서는 URL 파라미터도 영어로 변경해야 하고, 백엔드에서 시리얼라이저로 반환하는 데이터들도 영어로 변경해야 하고... 이모저모 할 일이 많을 것 같습니다만, 그외에는 어찌할 도리가 없을 것 같습니다.

---

## 📚 출처

[https://blog.logrocket.com/build-chat-application-react-django-channels/](https://blog.logrocket.com/build-chat-application-react-django-channels/)

</div>
